/* Generated By:JJTree: Do not edit this line. ASTDot.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;

public
class ASTDot extends SimpleNode {
  public ASTDot(int id) {
    super(id);
  }

  public ASTDot(JavaMMParser p, int id) {
    super(p, id);
  }


  @Override
  public String generateCode() {
    if (methodName().equals("length")) {
      return this.children[0].generateCode() + "arraylength\n";
    }

    FunctionSymbol symbol = this.getSymbol();

    StringBuilder code = new StringBuilder();

    if (!symbol.isStatic())
      code.append(this.children[0].generateCode()); // Object code

    // Code for arguments
    for (Node arg : this.methodArgs())
      code.append(arg.generateCode());

    if (symbol.isStatic())
      code.append("invokestatic " + jvmSignature() + "\n");
    else code.append("invokevirtual " + jvmSignature() + "\n");

    if (!getType().equals("void") && returnIgnored())
      code.append("pop\n");

    return code.toString();
  }


  private boolean returnIgnored() {
    // Checking if the return value is ignored.
    // Can only happen if Dot is directly inside If/Else, While or at the root
    Node parent = this.parent;
    if (parent instanceof ASTMethodContent)
      return true;
    if (parent instanceof ASTCodeBlock)
      return true;
    if (parent instanceof ASTWhile && parent.jjtGetChild(1) == this)
      return true;
    if (parent instanceof ASTIf && (parent.jjtGetChild(1) == this || parent.jjtGetChild(2) == this))
      return true;
    return false;
  }

  @Override
  public StackLimitValues calculateStackLimit(StackLimitValues slv){
    if (methodName().equals("length")) {
      return children[0].calculateStackLimit(slv);
    }

    boolean isStatic = this.getSymbol().isStatic();
    if (!isStatic)
      slv = children[0].calculateStackLimit(slv);
    for (Node child : this.methodArgs())
      slv = child.calculateStackLimit(slv);

    int stackPop = this.methodArgs().length;
    if (!isStatic)
      stackPop++;
    if (!getType().equals("void"))
      stackPop--;
    slv.decStack(stackPop);

    if (!getType().equals("void") && returnIgnored())
      slv.decStack(1);
    return slv;
  }

  private FunctionSymbol getSymbol() {
    return this.symbolTable.getFunctionSymbol(callerType(), methodSignature());
  }

  private String methodName() {
    return this.children[1].jjtGetChild(0).toString();
  }

  private Node[] methodArgs() {
    return Arrays.copyOfRange(this.children[1].jjtGetChildren(), 1, this.children[1].jjtGetNumChildren());
  }

  private String jvmSignature() {
    StringBuilder signature = new StringBuilder();
    signature.append(callerType()); // Object Type
    signature.append("/" + methodName() + "("); // Method name

    for (Node arg : this.methodArgs()) { // Arguments
      signature.append(ASTType.generateCodeChar(arg.getType()));
    }
    signature.append(")");
    signature.append(ASTType.generateCodeChar(this.getType()));

    return signature.toString();
  }

  private String methodSignature() {
    StringBuilder signature = new StringBuilder();
    signature.append(methodName() + "("); // Method name

    Node[] args = this.methodArgs();
    for (int i = 0; i < args.length; i++) {
      signature.append(args[i].getType());
      if (i != args.length - 1)
        signature.append(",");
    }

    signature.append(")");
    return signature.toString();
  }


  private String callerType() {
    String callerType = this.children[0].getType();
    if (callerType == null)
      return null;
    if (callerType.equals("class"))
      return this.children[0].toString();
    return callerType;
  }

  @Override
  public String getType() {
    if (methodName().equals("length"))
      return "int";
    FunctionSymbol symbol = symbolTable.getFunctionSymbol(callerType(), methodSignature());
    if (symbol == null)
      return null;
    return symbol.getReturnType();
  }



  private boolean argsSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    boolean isSemanticallyCorrect = true;
    for (Node child : this.methodArgs()) {
      if (isClassName(child)) {
        isSemanticallyCorrect = false;
        System.err.println("Error: " + child + " is not valid as a method argument (of function \"" + methodName() + "\") at line " + ((SimpleNode)child).line + ", column " + ((SimpleNode)child).column + ".");
      }
      else isSemanticallyCorrect &= child.isSemanticallyCorrect(varInitTable);
    }
    return isSemanticallyCorrect;
  }

  private boolean isClassName(Node node) {
    return node instanceof ASTIdentifier && this.symbolTable.getVarSymbol(node.toString()) == null && this.symbolTable.checkClassImport(node.toString());
  }

  private boolean inexistentVariable(Node node) {
    return node instanceof ASTIdentifier && this.symbolTable.getVarSymbol(node.toString()) == null;
  }

  @Override
  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    this.varInitTable = varInitTable;
    Node caller = children[0];

    if (methodName().equals("length")) {
      if (!caller.isSemanticallyCorrect(varInitTable))
        return false;
      String callerType = caller.getType();
      if (callerType.equals("int[]"))
        return true;
      else System.err.println("Error: Tried to call \".length\" on non array. Found type: " + callerType + " at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
      return false;
    }

    String methodSignature = this.methodSignature();

    if (isClassName(caller)) {
      if (!argsSemanticallyCorrect(varInitTable))
        return false;

      FunctionSymbol symbol = this.symbolTable.getFunctionSymbol(caller.toString(), methodSignature);
      if (symbol == null) {
        System.err.println("Error: Class \"" + caller + "\" does not contain static method \"" + methodSignature + "\" at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
        return false;
      } else if (!symbol.isStatic()) {
        System.err.println("Error: Method \"" + caller + "." + methodSignature + "\" is not static at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
        return false;
      }
      return true;
    }
    else if (inexistentVariable(caller)) {
      System.err.println("Error: Symbol \"" + caller + "\" does not exist at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
      argsSemanticallyCorrect(varInitTable);
      return false;
    }
    else {
      boolean callerSemanticallyCorrect = caller.isSemanticallyCorrect(varInitTable);
      boolean argsSemanticallyCorrect = this.argsSemanticallyCorrect(varInitTable);
      if (!callerSemanticallyCorrect || !argsSemanticallyCorrect)
        return false;

      String type = caller.getType();
      FunctionSymbol symbol = this.symbolTable.getFunctionSymbol(type, methodSignature);
      if (symbol == null) {
        System.err.println("Error: Class \"" + type + "\" does not contain method \"" + methodSignature + "\" at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
        return false;
      }
      else if (symbol.isStatic()) {
        System.err.println("Error: Method \"" + type + "." + methodSignature + "\" is static at line " + ((SimpleNode)caller).line + ", column " + ((SimpleNode)caller).column + ".");
        return false;
      }
      else return true;
    }
  }
}
/* JavaCC - OriginalChecksum=5a58603a33acc87aa7b7d53e50ce8e72 (do not edit this line) */
