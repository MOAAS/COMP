/* Generated By:JJTree: Do not edit this line. ASTIf.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.*;

public
class ASTIf extends SimpleNode {
  public ASTIf(int id) {
    super(id);
  }

  public ASTIf(JavaMMParser p, int id) {
    super(p, id);
  }


  @Override
  public Node constantPropagation(HashMap<String,Node> vm){
    children[0] = children[0].constantPropagation(vm);
    HashMap<String,Node>vmIf = new HashMap<String,Node>(vm); //copy of vm for both if and else blocks
    HashMap<String,Node>vmElse = new HashMap<String,Node>(vm);

    children[1] = children[1].constantPropagation(vmIf);
    children[2] = children[2].constantPropagation(vmElse);

    mergeVariableMap(vm,vmIf,vmElse); //merges both vm's

    //System.out.println("Variable Map If else:");
    //for (HashMap.Entry<String, Node> entry : vm.entrySet())
    //  System.out.println("Variable: " + entry.getKey() + entry.getValue());
    //System.out.println("");


    return this;
  }

  private void mergeVariableMap(HashMap<String,Node> vmOriginal,HashMap<String,Node> vmIf, HashMap<String,Node> vmElse){
    Iterator<HashMap.Entry<String,Node>> iter = vmOriginal.entrySet().iterator();
    while (iter.hasNext()) {
      HashMap.Entry<String, Node> entry = iter.next();
      String key = entry.getKey();
      Node vs = entry.getValue();
      if(!vmIf.containsKey(key) || !vmIf.get(key).toString().equals(vs.toString())    ||     !vmElse.containsKey(key) || !vmElse.get(key).toString().equals(vs.toString()))
      iter.remove(); //if variable is not constant anymore or it changed to diferent constant in one or more of the blocks it gets removed.
    }
  }

  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    this.varInitTable = varInitTable;
    boolean isSemanticallyCorrect = true;
    isSemanticallyCorrect &= children[0].isSemanticallyCorrect(varInitTable);
    isSemanticallyCorrect &= children[1].isSemanticallyCorrect(new HashMap<String,Integer>(varInitTable)); //copy of varInitTable for both if and else codeblocks
    isSemanticallyCorrect &= children[2].isSemanticallyCorrect(new HashMap<String,Integer>(varInitTable));

    HashMap<String, Integer> varInitTableIf = children[1].getVarInitTable();
    HashMap<String, Integer> varInitTableElse = children[2].getVarInitTable();
    this.mergeVarInitTables(varInitTableIf,varInitTableElse); //merges tables form both if and else blocks into the current varInitTables

    if(!children[0].getType().equals("boolean")){
      System.err.println("Error: If expression is not a boolean. Found: " + children[0].getType() + " at line " + this.line + ", column " + this.column + ".");
      return false;
    }
    return isSemanticallyCorrect;
  }

  private void mergeVarInitTables(HashMap<String, Integer> varInitTableIf,HashMap<String, Integer> varInitTableElse){
    for (HashMap.Entry<String, Integer> entry : this.varInitTable.entrySet()) {
      String key = entry.getKey();
      int value = entry.getValue();
      if(value == 2) // if the variable was already initialized, it will still be even after the if block
        continue;
      int sum = varInitTableIf.get(key) + varInitTableElse.get(key);
      if(sum == 4) // if both if and else blocks initialized a variable, it is initialized
        varInitTable.put(key,2);
      else if(sum == 0 )// if none if and else blocks initialized a variable, it continues uninitialized
        continue;
      else  varInitTable.put(key,1); //if only one block initialized a variable, it may be initialized.
    }
  }

  @Override
  public String generateCode() {
    String elseLabel = "LABEL" +  SimpleNode.getLabel();
    String endLabel = "LABEL" + SimpleNode.getLabel();

    StringBuilder code = new StringBuilder();
    code.append(generateIfCode(children[0], elseLabel, true));
    code.append(children[1].generateCode());
    code.append("goto " + endLabel + "\n");
    code.append(elseLabel + ":\n");
    code.append(children[2].generateCode());
    code.append(endLabel + ":\n");
    return code.toString();
  }

  public static String generateIfCode(Node ifExpression, String toLabel, boolean jumpIfFalse) {
    if (ifExpression instanceof ASTLessThan) {
      // EXPR < 0
      if (ifExpression.jjtGetChild(1).toString().equals("0"))
        return ifExpression.jjtGetChild(0).generateCode() + makeIfInstruction("iflt", toLabel, jumpIfFalse);

      // EXPR1 < EXPR2
      return ifExpression.jjtGetChild(0).generateCode() +
          ifExpression.jjtGetChild(1).generateCode() +
          makeIfInstruction("if_icmplt", toLabel, jumpIfFalse);
    }
    // BOOLEAN (check if equal to 1)
    return ifExpression.generateCode() + makeIfInstruction("ifne", toLabel, jumpIfFalse);
  }

  private static String makeIfInstruction(String instruction, String toLabel, boolean invert) {
    if (invert) {
      switch (instruction) {
        case "iflt": instruction = "ifge"; break;
        case "if_icmplt": instruction = "if_icmpge"; break;
        case "ifne": instruction =  "ifeq"; break;
        default: throw new RuntimeException("ConvertIfInstruction: Unexpected instruction " + instruction);
      }
    }
    return instruction + " " + toLabel + "\n";
  }

  @Override
  public StackLimitValues calculateStackLimit(StackLimitValues slv){
    this.children[0].calculateStackLimit(slv);
    slv.decStack(1);
    this.children[1].calculateStackLimit(slv);
    this.children[2].calculateStackLimit(slv);
    return slv;
  }

  public Node deadCodeElimination() {
    super.deadCodeElimination();
    if (children[0] instanceof ASTTrue) {
      if (isEmptyBlock(children[1]))
        return null;
      System.err.println("Warning: If expression will always be true at line " + this.line + ", column " + this.column + ".");
      return children[1];
    }
    if (children[0] instanceof ASTFalse) {
      if (isEmptyBlock(children[2]))
        return null;
      System.err.println("Warning: If expression will always be false at line " + this.line + ", column " + this.column + ".");
      return children[2];
    }

    if (isEmptyBlock(children[1]) && isEmptyBlock(children[2]))
      return null;
    return this;
  }

  private static boolean isEmptyBlock(Node node) {
    return node instanceof ASTCodeBlock && node.jjtGetNumChildren() == 0;
  }
}
/* JavaCC - OriginalChecksum=5c035542582c0da53d523f00bb3c3436 (do not edit this line) */
