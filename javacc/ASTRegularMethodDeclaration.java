/* Generated By:JJTree: Do not edit this line. ASTRegularMethodDeclaration.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.*;

public
class ASTRegularMethodDeclaration extends SimpleNode {
  String methodSignature = "";

  public ASTRegularMethodDeclaration(int id) {
    super(id);
  }

  public ASTRegularMethodDeclaration(JavaMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String generateCode() {
    String methodType = ASTType.generateCodeChar(this.methodType());

    Node methodContent = this.methodContent();
    Node methodReturn = this.methodReturn();

    int stackLimitContent = (methodContent == null) ? 0 : methodContent.calculateStackLimit(new StackLimitValues()).maxStack;
    int stackLimitReturn = methodReturn.calculateStackLimit(new StackLimitValues()).maxStack;

    int max = Math.max(stackLimitContent, stackLimitReturn);


    StringBuilder code = new StringBuilder();
    code.append(".method public " + this.methodName() + "(" + methodVars().generateCode() + ")" + methodType + "\n");
    code.append(".limit stack " + max + "\n");
    code.append(".limit locals " + countLocals() + "\n");
    if (methodContent !=  null)
      code.append(methodContent.generateCode());
    code.append(methodReturn.generateCode());
    code.append(".end method\n\n");

    return code.toString();
  }

  @Override
  public void rOptimization(int k) {
    optimizeRegisters(k, methodSignature);
  }

  @Override
  public Node constantPropagation(HashMap<String,Node> vm){
    vm = new HashMap<String,Node>(); //start new variable map
    for (int i = 0; i < children.length; i++) {
      children[i] = children[i].constantPropagation(vm);
    }
    return this;
  }

  @Override
  public StackLimitValues calculateStackLimit(StackLimitValues slv){
    Node methodContent = methodContent();
    if (methodContent == null)
      slv = methodContent.calculateStackLimit(slv);
    return methodReturn().calculateStackLimit(slv);
  }

  private int countLocals() {
    SymbolTable table = ((MethodSymbol)(this.getSymbolTable().get(methodSignature))).getMethodTable();
    return table.getMaxOrder() + 1;
  }

  public static int countVarDeclarations(Node node) {
    if (node == null)
      return 0;
    int numDeclarations = 0;
    for (Node child : node.jjtGetChildren()) {
      if (child instanceof ASTVarDeclaration)
        numDeclarations++;
    }
    return numDeclarations;
  }

  private String methodType() {
    return children[0].jjtGetChild(0).toString();
  }

  private String methodName() {
    return children[1].jjtGetChild(0).toString();
  }

  private Node methodVars() {
    return children[2];
  }

  private Node methodContent() {
    if (this.children.length == 4)
      return null;
    return this.children[3];
  }

  private Node methodReturn() {
    if (this.children.length == 4)
      return this.children[3];
    return this.children[4];
  }

  @Override
  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    Node[] argNodes = this.children[2].jjtGetChildren();
    for (Node argNode : argNodes){
      varInitTable.put(argNode.jjtGetChildren()[1].toString(),2);
    }
    Node returnNode = this.methodReturn();
    Node contentNode = this.methodContent();
    boolean contentSemanticallyCorrect = contentNode == null ? true : contentNode.isSemanticallyCorrect(varInitTable);
    boolean returnSemanticallyCorrect = returnNode.isSemanticallyCorrect(varInitTable);

    if (!returnSemanticallyCorrect)
      return false;
    String returnNodeType = returnNode.jjtGetChild(0).getType();
    String methodType = methodType();
    if (!returnNodeType.equals(methodType)) {
      System.err.println("Error: Invalid return expression. Required: " + methodType + ", Provided: " + returnNodeType + " at line " + ((SimpleNode)returnNode.jjtGetChild(0)).line + ", column " + ((SimpleNode)returnNode.jjtGetChild(0)).column + ".");
      return false;
    }
    return contentSemanticallyCorrect;
  }


  @Override
  public boolean explore(int order, SymbolTable parentTable) {
    this.setSymbolTable(parentTable);

    Node returnTypeNode = null;
    Node methodNameNode = null;
    String methodName = "";
    boolean isStatic = false;
    StringBuilder methodParams = new StringBuilder();

    boolean validParamTypes = true;

    for(Node childNode : children) {
      switch (childNode.toString()) {
        case "MethodType":
          returnTypeNode = childNode.jjtGetChild(0);
          break;
        case "MethodName":
          methodNameNode = childNode.jjtGetChild(0);
          methodName = methodNameNode.toString();
          break;
        case "MethodVars":
          methodParams.append("(");
          for (Node paramNode : childNode.jjtGetChildren()) {
            String varType = paramNode.jjtGetChild(0).toString();

            if(paramNode == childNode.jjtGetChild(childNode.jjtGetNumChildren() - 1))
              methodParams.append(varType);
            else methodParams.append(varType).append(",");

            validParamTypes = validParamTypes & ASTVarDeclaration.validateType(paramNode.jjtGetChild(0), parentTable);
          }
          methodParams.append(")");
          break;
      }
    }

    this.methodSignature = methodName + methodParams.toString();

    if (!ASTVarDeclaration.validateType(returnTypeNode, parentTable) || !validParamTypes)
      return false;

    String fullName = methodName + methodParams.toString();
    if(parentTable.checkIfSymbolExists(fullName)) {
      System.err.println("Error: Duplicate method declaration \"" + fullName + "\" at line " + ((SimpleNode)methodNameNode).line + ", column " + ((SimpleNode)methodNameNode).column + ".");
      return false;
    }

    MethodSymbol methodSymbol = new MethodSymbol(returnTypeNode.toString(), isStatic, this, parentTable, -1);
    parentTable.put(fullName, methodSymbol);
    //String className = parentTable.getRoot().jjtGetParent().jjtGetChild(0).jjtGetChild(0).toString();
    //methodSymbol.getMethodTable().put("this", new VarSymbol(className, 0));
    return methodSymbol.createSymbolTable();
  }
}
/* JavaCC - OriginalChecksum=211f0ae5d550c364087551f7101b4d8b (do not edit this line) */
