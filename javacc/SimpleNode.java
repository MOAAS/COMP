/* Generated By:JJTree: Do not edit this line. SimpleNode.java Version 6.1 */
/* JavaCCOptions:MULTI=false,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.*;

public class SimpleNode implements Node {
  private static int nextLabel = 1;

  protected Node parent;
  protected Node[] children = new Node[0];
  protected int id;
  protected int line;
  protected int column;
  protected Object value;
  protected JavaMMParser parser;
  protected SymbolTable symbolTable = null;
  protected HashMap<String, Integer> varInitTable = null;

  public SymbolTable getSymbolTable() {
    return symbolTable;
  }

  public  HashMap<String, Integer> getVarInitTable() {
    return varInitTable;
  }

  public void setSymbolTable(SymbolTable symbolTable) {
    this.symbolTable = symbolTable;
  }

  public boolean explore(int order, SymbolTable symbolTable) {
    setSymbolTable(symbolTable);

    boolean success = true;
    for(int i = 0; i < this.children.length; i++) {
      if(!this.children[i].explore(i + order, symbolTable)) success = false;
    }

    return success;
  }

  public static int getLabel() {
    return nextLabel++;
  }

  public static int resetLabel() {
    return nextLabel = 1;
  }

  public StackLimitValues calculateStackLimit(StackLimitValues slv){//used to calculate stack limit values for each method
    for (Node child : children)
      slv = child.calculateStackLimit(slv);
    return slv;
  }


  //goes through AST and replaces variable nodes with constant nodes when it can be replaced | vm -> hashmap that stores variable and the associated node when it has a constant value
  public Node constantPropagation(HashMap<String,Node> vm){
    for (int i = 0; i < children.length; i++) {
      children[i] = children[i].constantPropagation(vm);
    }
    return this;
  }
  //checks every node in a while and adds variables that changed to a set
  public void whileAnalyser(Set<String> wa){
    for (int i = 0; i < children.length; i++) {
      children[i].whileAnalyser(wa);
    }
  }

  //goes through AST and checks if node is semantically correct. Var init table is used to detect variable initialization errors.
  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {//In varInitTable, variables can have 3 distinct states: 2: initiliazed; 1: may not be initialized (ifs/whiles); 0: not initialized
    this.varInitTable = varInitTable;
    boolean isSemanticallyCorrect = true;
    for (Node child : children)
      isSemanticallyCorrect &= child.isSemanticallyCorrect(varInitTable);
    return isSemanticallyCorrect;
  }


  public SimpleNode(int i) {
    id = i;
  }

  public SimpleNode(JavaMMParser p, int i) {
    this(i);
    parser = p;
  }

  public void jjtOpen() {
  }

  public void jjtClose() {
  }

  public void jjtSetParent(Node n) { parent = n; }
  public Node jjtGetParent() { return parent; }

  public void jjtAddChild(Node n, int i) {
    if (children == null) {
      children = new Node[i + 1];
    } else if (i >= children.length) {
      Node c[] = new Node[i + 1];
      System.arraycopy(children, 0, c, 0, children.length);
      children = c;
    }
    children[i] = n;
  }

  public Node jjtGetChild(int i) {
    return children[i];
  }

  public int jjtGetNumChildren() {
    return (children == null) ? 0 : children.length;
  }

  public Node[] jjtGetChildren() {
    return this.children;
  }

  public Node jjtGetLastChild() { return this.children[this.children.length - 1]; }

  public void jjtSetValue(Object value) { this.value = value; }

  /* You can override these two methods in subclasses of SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */

  public String toString() {
    return JavaMMParserTreeConstants.jjtNodeName[id];
  }
  public String toString(String prefix) { return prefix + toString(); }

  /* Override this method if you want to customize how the node dumps
     out its children. */

  public void dump(String prefix) {
    System.out.println(toString(prefix));
    if (children != null) {
      for (int i = 0; i < children.length; ++i) {
        SimpleNode n = (SimpleNode)children[i];
        if (n != null) {
          n.dump(prefix + " ");
        }
      }
    }
  }

  public int getId() {
    return id;
  }

  public String generateCode() {
    StringBuilder code = new StringBuilder();
    for (Node child : children) {
      code.append(child.generateCode());
    }

    return code.toString();
  }

  public Node expressionSimplification() {
    for (int i = 0; i < children.length; i++) {
      children[i] = children[i].expressionSimplification();
    }

    return this;
  }

  public Node deadCodeElimination() {
    // deadCodeElimination will return null if corresponding node won't even be considered
    // if (false) { anything.... } else {}, for instance
    for (int i = 0; i < children.length; i++) {
      children[i] = children[i].deadCodeElimination();
    }
    children = removeNulls(children);
    return this;
  }

  public void loopUnrolling() {
    // Performs loop unrolling throughout its children
    for (Node child : children) {
      child.loopUnrolling();
    }

    for (int i = 0; i < children.length - 1; i++) {
      // Wants an assignment followed by a while
      Node assignment = children[i];
      Node whileNode = children[i + 1];

      // Ensures expected tree structure, i = initial; while (i < max) { ... i = i + increment; }
      if (ASTAssignment.isIntegerAssignment(assignment) && ASTWhile.isForLoop(whileNode, assignment)) {
        int initial = Integer.parseInt(assignment.jjtGetChild(1).toString());
        int max = Integer.parseInt(whileNode.jjtGetChild(0).jjtGetChild(1).toString());
        int increment = Integer.parseInt(whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(1).jjtGetChild(1).toString());

        // Doesn't unroll potentially infinite loops
        // Or loops that won't start
        if (increment == 0 || initial == max)
          continue;


        // Tries a prime multiplier from 2 to 7, numIterations must be multiple of that
        // It numIterations is not a multiple of any of them, it doesn't unroll.
        // Multiplier will be the number of times the loop content will be multiplied
        int multiplier = 1;
        int numIterations = (int)Math.ceil((max - initial) / (double)increment);

        if (numIterations % 7 == 0)
          multiplier = 7;
        else if (numIterations % 5 == 0)
          multiplier = 5;
        else if (numIterations % 3 == 0)
          multiplier = 3;
        else if (numIterations % 2 == 0)
          multiplier = 2;
        ((ASTWhile)children[i + 1]).unrollNode(multiplier);
      }

    }
  }

  private static Node[] removeNulls(Node[] array) {
    List<Node> nonNulls = new ArrayList<>();

    for(Node elem : array) {
      if (elem != null)
        nonNulls.add(elem);
    }

    if (nonNulls.size() == array.length)
      return array;
    return nonNulls.toArray(new Node[0]);
  }

  public String getType() {
    throw new RuntimeException("Invalid gettype(). Called on class: " + this.getClass().getName());
  }

  public void rOptimization(int k) {
    for(Node child : children) {
      ((SimpleNode)child).rOptimization(k);
    }
  }

  /*
  * Graph Colouring Algorithm to minimize registers used
  *   k - maximum registers used
  *   signature - respective function's signature
  */
  public void optimizeRegisters(int k, String signature) {
    // Create the graph with all variable use intersections
    HashMap<String, LiveNode> liveGraph = createLiveGraph(this); //Creates liveness Graph from the AST
    int numNodes = liveGraph.size();
    Stack<LiveNode> colorableNodes = new Stack();

    int testK = k;
    boolean colorable = false;
    // First, check if it's colorable: if it's not, iterate until we find the minimum registers needed and send error.
    while(!colorable) {
      for (Iterator<String> it = liveGraph.keySet().iterator(); it.hasNext(); ) {
        String next = it.next();
        LiveNode node = liveGraph.get(next);
        //System.out.println("Node " + node.varName + " has " + node.edges.size() + " edges:");
        if (elementsNotIn(node.edges, colorableNodes) < testK) {
          colorableNodes.push(node);
          liveGraph.remove(next);
          it = liveGraph.keySet().iterator();
        }
      }

      // Reset graph to before removing nodes
      liveGraph = createLiveGraph(this);

      // If all nodes were added to the stack, then graph is colorable in k colors
      if (colorableNodes.size() == numNodes)
        colorable = true;
      // if not, the graph is not colorable in k colors
      else {
        colorableNodes.clear();
        testK++;
      }
    }

    if(testK != k)
      throw new RuntimeException(signature + " not colorable in " + k + " colors, minimum would be " + testK + ".");

    // Next, iterate through stack and assign a color to each of the nodes
    while (!colorableNodes.empty()) {
      LiveNode currNode = liveGraph.get(colorableNodes.pop().varName);
      // If the node already has a color (such as "this" which is always in register 0, or the parameters), then keep it
      if(currNode.colorIndex != -1)
        continue;
      // Iterate through possible colors and assign the first one to be available
      for (int currColor = 0; currColor < k; currColor++) {
        for (Iterator<LiveNode> it = currNode.edges.iterator(); it.hasNext(); ) {
          LiveNode next = it.next();
          if (next.colorIndex == currColor)
            break;
          // If all neighbor nodes are a different color, apply it to the node
          if (!it.hasNext()) {
            currNode.colorIndex = currColor;
            break;
          }
        }

        // If this color has been assigned to the node, move on to next node
        if(currNode.colorIndex != -1)
          break;
      }

      // If no color was assigned, then the node has 0 edges, which means it can have any color.
      if (currNode.colorIndex == -1) {
        currNode.colorIndex = 0;
      }
    }

    System.out.println("--- " + signature + " orders ---");

    //Debug to show nodes and edges
    /*
    for (Iterator<String> it = liveGraph.keySet().iterator(); it.hasNext(); ) {
      String next = it.next();
      LiveNode node = liveGraph.get(next);
      System.out.println("Node: " + node.varName);
      for(LiveNode edge: node.edges) {
        System.out.println("\tEdge: " + edge.varName);
      }
    }
    */


    System.out.println("Orders before:");
    for (Iterator<String> it = liveGraph.keySet().iterator(); it.hasNext(); ) {
      String next = it.next();
      if(next.equals("this")) {
        System.out.println(next + ": " + liveGraph.get(next).colorIndex);
        continue;
      }
      System.out.println(next + ": " + ((MethodSymbol)(this.getSymbolTable().get(signature))).getMethodTable().get(next).getOrder());
    }

    System.out.println("Orders after:");
    for (Iterator<String> it = liveGraph.keySet().iterator(); it.hasNext(); ) {
      String next = it.next();
      if(next.equals("this")) {
        System.out.println(next + ": " + liveGraph.get(next).colorIndex);
        continue;
      }
      System.out.println(next + ": " + (liveGraph.get(next).colorIndex));
      ((MethodSymbol)(this.getSymbolTable().get(signature))).getMethodTable().get(next).setOrder(liveGraph.get(next).colorIndex);
    }
  }

  public static int elementsNotIn(Set<LiveNode> edges, Stack<LiveNode> stacked) {
    int n = 0;
    for(Iterator<LiveNode> it = edges.iterator(); it.hasNext(); ) {
      LiveNode node = it.next();
      //System.out.print(node.varName + " ");
      if(!stacked.contains(node))
        n++;
    }
    //System.out.println("");
    return n;
  }

  protected HashMap<String, LiveNode> createLiveGraph(Node rootNode) {
    HashMap<String, LiveNode> graph = new HashMap<>();
    List<LiveNode> activeList = new ArrayList<>();
    for(Node node : rootNode.jjtGetChildren()) {
      ((SimpleNode) node).fillGraph(graph, activeList);
    }

    return graph;
  }

  /*
    The fillGraph Algorithm creates the nodes and edges in the method
    When a node is used or defined it is added to the activeList
    When a node is used it goes backwards through the activeList and creates edges with every node between itself and the last time it was used/defined
    Additionally there is a special case with if and when blocks.
    Here the vars used/defined are ignored when the same var from outside the codeBlock goes backwards creating edges with other vars.
    This happens because these code blocks are conditional in nature, as such we can't assume those defs/uses have been performed when running the optimization
   */
  public void fillGraph(HashMap<String, LiveNode> graph, List<LiveNode> activeList) {
    for(Node node : children) ((SimpleNode) node).fillGraph(graph, activeList);
  }

}

/* JavaCC - OriginalChecksum=5f89383f8126a3d5cc9f7c5808dde021 (do not edit this line) */
