/* Generated By:JJTree: Do not edit this line. ASTMainDeclaration.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.*;

public
class ASTMainDeclaration extends SimpleNode {
  public ASTMainDeclaration(int id) {
    super(id);
  }

  public ASTMainDeclaration(JavaMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String generateCode() {

    Node methodContent = this.children[1];
    StackLimitValues slv = new StackLimitValues();
    int maxStack = methodContent.calculateStackLimit(slv).maxStack;

    StringBuilder code = new StringBuilder();
    code.append(".method public static main([Ljava/lang/String;)V\n");
    code.append(".limit stack "+ maxStack +"\n");
    code.append(".limit locals " + countLocals() + "\n");
    code.append(methodContent.generateCode());
    code.append("return\n");
    code.append(".end method\n\n");

    return code.toString();
  }


  public void rOptimization(int k) {
    optimizeRegisters(k, "main(String[])");
  }

  @Override
  public Node constantPropagation(HashMap<String,Node> vm){
    vm = new HashMap<String,Node>(); //start new variable map
    for (int i = 0; i < children.length; i++) {
      children[i] = children[i].constantPropagation(vm);
    }

   // System.out.println("Variable Map:");
   // for (HashMap.Entry<String, Node> entry : vm.entrySet())
   //   System.out.println("Variable: " + entry.getKey() + entry.getValue());
   // System.out.println("");


    return this;
  }

  @Override
  public StackLimitValues calculateStackLimit(StackLimitValues slv){
    return this.children[1].calculateStackLimit(slv);
  }

  private int countLocals() {
    SymbolTable table = ((MethodSymbol)(this.getSymbolTable().get("main(String[])"))).getMethodTable();
    return table.getMaxOrder() + 1;
  }

  @Override
  public boolean explore(int order, SymbolTable parentTable) {
    this.setSymbolTable(parentTable);
    String returnType = "void", methodName = "main(String[])";

    if(parentTable.checkIfSymbolExists(methodName)) {
      System.err.println("Error: Duplicate main method for class: " + parentTable.getClassName());
      return false;
    }
    else {
      MethodSymbol methodSymbol = new MethodSymbol(returnType, true, this, parentTable, order);
      parentTable.put(methodName, methodSymbol);

      String argName = this.jjtGetChild(0).jjtGetChild(0).toString();
      methodSymbol.getMethodTable().put(argName, new VarSymbol("String[]", 0));

      return methodSymbol.createSymbolTable();
    }
  }

  @Override
  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    varInitTable.put(this.children[0].jjtGetChildren()[0].toString(),2);
    return super.isSemanticallyCorrect(varInitTable);
  }
}
/* JavaCC - OriginalChecksum=35053094c4c475a397233574fa9e7305 (do not edit this line) */
