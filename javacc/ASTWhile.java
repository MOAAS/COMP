/* Generated By:JJTree: Do not edit this line. ASTWhile.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */

import java.util.*;

public class ASTWhile extends SimpleNode {
  public ASTWhile(int id) {
    super(id);
  }

  public ASTWhile(JavaMMParser p, int id) {
    super(p, id);
  }

  @Override
  public Node constantPropagation(HashMap<String,Node> vm){
    Set<String> wa = new HashSet<String>();
    this.whileAnalyser(wa);  //while analyser to check which variables changed
    for (String temp : wa) { //remove changed variables from vm
      if (vm.containsKey(temp))
        vm.remove(temp);
    }

    HashMap<String,Node>vmWhile = new HashMap<String,Node>(vm);
    children[1] = children[1].constantPropagation(vmWhile); //check first in the while block
    mergeVariableMap(vm,vmWhile);
    children[0] = children[0].constantPropagation(vm);    //only then check the statement

    //System.out.println("Variable Map While:");
    //for (HashMap.Entry<String, Node> entry : vm.entrySet())
    //  System.out.println("Variable: " + entry.getKey() + entry.getValue());
    //System.out.println("");


    return this;
  }

  private void mergeVariableMap(HashMap<String,Node> vmOriginal,HashMap<String,Node> vmWhile){
    Iterator<HashMap.Entry<String,Node>> iter = vmOriginal.entrySet().iterator();
    while (iter.hasNext()) {
      HashMap.Entry<String, Node> entry = iter.next();
      String key = entry.getKey();
      Node vs = entry.getValue();
      if(!vmWhile.containsKey(key) || !vmWhile.get(key).toString().equals(vs.toString())) //if variable is not constant anymore or it changed to diferent constant  it gets removed.
        iter.remove();
    }
  }





  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    this.varInitTable = varInitTable;
    boolean isSemanticallyCorrect = true;
    isSemanticallyCorrect &= children[0].isSemanticallyCorrect(varInitTable);
    isSemanticallyCorrect &= children[1].isSemanticallyCorrect(new HashMap<String,Integer>(varInitTable));

    HashMap<String, Integer> varInitTableChild = children[1].getVarInitTable();
    this.mergeVarInitTables(varInitTableChild); //merge while table with current

    if(!children[0].getType().equals("boolean")){
      System.err.println("Error: While expression is not a boolean. Found: " + children[0].getType() + " at line " + this.line + ", column " + this.column + ".");
      return false;
    }
    return isSemanticallyCorrect;
  }

  private void mergeVarInitTables(HashMap<String, Integer> varInitTableChild){
    for (HashMap.Entry<String, Integer> entry : this.varInitTable.entrySet()) {
      String key = entry.getKey();
      int value = entry.getValue();
      if(value == 2) //if the variable was already initialized, it will still be even after the if block
        continue;
      int childVal = varInitTableChild.get(key);
      if(childVal == 2)// if while initialized a variable, it may be intialized
        varInitTable.put(key,1);
      else if(childVal == 0)// if while didnt initialize a variable, it continues uninitialized
        continue;
        else varInitTable.put(key,1);// if while may have initialized a variable, it may be intialized
    }
  }

  @Override
  public String generateCode() {
    String contentLabel = "LABEL" + SimpleNode.getLabel();
    String endLabel = "LABEL" + SimpleNode.getLabel();


    StringBuilder code = new StringBuilder();
    // Condition
    code.append(ASTIf.generateIfCode(children[0], endLabel, true));

    // Content
    code.append(contentLabel + ":\n");
    code.append(children[1].generateCode());

    // Condition again
    code.append(ASTIf.generateIfCode(children[0], contentLabel, false));
    code.append(endLabel + ":\n");
    return code.toString();
  }

  @Override
  public StackLimitValues calculateStackLimit(StackLimitValues slv){
    this.children[0].calculateStackLimit(slv);
    slv.decStack(1);
    this.children[1].calculateStackLimit(slv);
    return slv;
  }

  @Override
  public Node deadCodeElimination() {
    super.deadCodeElimination();
    if (children[0] instanceof ASTTrue) {
      System.err.println("Warning: While expression will always be true at line " + this.line + ", column " + this.column + ".");
      return this;
    }
    if (children[0] instanceof ASTFalse) {
      System.err.println("Warning: While expression will always be false at line " + this.line + ", column " + this.column + ".");
      return null;
    }
    return this;
  }

  public static boolean isForLoop(Node whileNode, Node assignmentNode) {
    try {
      String variableName = assignmentNode.jjtGetChild(0).toString();
      return whileNode instanceof ASTWhile &&
          // check if condition is of type var < num
          whileNode.jjtGetChild(0) instanceof ASTLessThan &&
          whileNode.jjtGetChild(0).jjtGetChild(0) instanceof ASTIdentifier &&
          whileNode.jjtGetChild(0).jjtGetChild(0).toString().equals(variableName) &&
          whileNode.jjtGetChild(0).jjtGetChild(1) instanceof ASTInteger &&
          // check if ends with var = var + 1
          whileNode.jjtGetChild(1).jjtGetLastChild() instanceof ASTAssignment &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(0) instanceof ASTIdentifier &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(0).toString().equals(variableName) &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(1) instanceof ASTAdd &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(1).jjtGetChild(0) instanceof ASTIdentifier &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(1).jjtGetChild(0).toString().equals(variableName) &&
          whileNode.jjtGetChild(1).jjtGetLastChild().jjtGetChild(1).jjtGetChild(1) instanceof ASTInteger;
    } catch (ArrayIndexOutOfBoundsException e) {
        return false;
    }
  }

  public void unrollNode(int multiplier) {
    if (!(this.children[1] instanceof ASTCodeBlock)) {
      throw new RuntimeException("Can't unroll single instruction loops!");
    }

    Node[] contents = children[1].jjtGetChildren();

    ASTCodeBlock newContents = new ASTCodeBlock(JavaMMParserTreeConstants.JJTCODEBLOCK);
    newContents.children = new Node[contents.length * multiplier];

    for (int i = 0; i < multiplier; i++) {
      System.arraycopy(contents, 0, newContents.children, i * contents.length, contents.length);
    }

    this.children[1] = newContents;
  }

  public void fillGraph(HashMap<String, LiveNode> graph, List<LiveNode> activeList) {
    for(Node node : children) ((SimpleNode) node).fillGraph(graph, activeList);
    for(Node node : children) ((SimpleNode) node).fillGraph(graph, activeList);
    //done twice to emulate a loop    
  }
}


/* JavaCC - OriginalChecksum=71b95df31f871679c4c75c9ab386433d (do not edit this line) */
