/* Generated By:JJTree: Do not edit this line. ASTClassDeclaration.java Version 6.1 */
/* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
import java.util.HashMap;

public
class ASTClassDeclaration extends SimpleNode {
  public ASTClassDeclaration(int id) {
    super(id);
  }

  public ASTClassDeclaration(JavaMMParser p, int id) {
    super(p, id);
  }

  @Override
  public String generateCode() {
    StringBuilder code = new StringBuilder();

    code.append(children[0].generateCode());

    for (int i = 1; i < children.length; i++) {
      code.append(children[i].generateCode());
    }

    code.append(".method public <init>()V\n");
    code.append("  aload_0\n");
    code.append("  invokenonvirtual " + ((ASTClassInfo)this.children[0]).getSuperClass() + "/<init>()V\n");
    code.append("  return\n");
    code.append(".end method\n\n");



    return code.toString();
  }

  @Override
  public boolean explore(int order, SymbolTable symbolTable) {
    this.setSymbolTable(symbolTable);
    String parentName = "";
    SimpleNode node = (SimpleNode) this.jjtGetChild(0); //get class info node


    String className = node.jjtGetChild(0).toString();
    if(node.jjtGetNumChildren() == 2) parentName = node.jjtGetChild(1).toString();

    if (parentName.equals(className)) {
      System.err.println("Error: Can't extend class from itself.");
      return false;
    }
    if (!parentName.equals("") && !symbolTable.checkIfSymbolExists(parentName)) {
      System.err.println("Error: Extended class was not imported.");
      return false;
    }



    ClassSymbol classSymbol = new ClassSymbol(symbolTable, parentName, this, -1);

    if(symbolTable.checkIfSymbolExists(className)) {
      System.err.println("Error: Duplicate class declaration: " + className);
      return false;
    }
    else {
      symbolTable.put(className, classSymbol);
      return classSymbol.createSymbolTable();
    }
  }

  public boolean isSemanticallyCorrect(HashMap<String, Integer> varInitTable) {
    boolean isSemanticallyCorrect = true;
    for (Node child : children) {
      if(child instanceof ASTVarDeclaration){
        varInitTable.put(child.jjtGetChild(1).toString(),2);
      }
      HashMap<String,Integer> varInitMap = new HashMap<String,Integer>(varInitTable);
      isSemanticallyCorrect &= child.isSemanticallyCorrect(varInitMap);
/*
      System.out.println("Var map:");
      Iterator it = varInitMap.entrySet().iterator();
      while (it.hasNext()) {
        Map.Entry pair = (Map.Entry)it.next();
        System.out.println(pair.getKey() + " = " + pair.getValue());
      }
      System.out.println("");

 */

    }
    return isSemanticallyCorrect;
  }
}
/* JavaCC - OriginalChecksum=2d8da2a36c0308baf7b86e7859285d4f (do not edit this line) */
